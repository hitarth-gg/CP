{
    /* ------------------------------------------------------ */
  "String Double Hashing": {
    "prefix": "string_double_hashing",
    "scope": "cpp",
    "body": [
      "struct Hashing{",
      "    string s;",
      "    int n;",
      "    int primes; // number of different primes used for hashing",
      "    vector<ll> hashPrimes = {1000000009, 100000007}; // prime numbers used as moduli for hashing",
      "    const ll base = 31; // base value used for the rolling hash",
      "    vector<vector<ll>> hashValues; // vector to store hash values of prefixes of the string for each prime",
      "    vector<vector<ll>> powersOfBase; // a 2D vector to store powers of the base for each prime",
      "    vector<vector<ll>> inversePowersOfBase; // a 2D vector to store inverse powers of the base for each prime.",
      "    Hashing(string a){",
      "        primes = hashPrimes.size();",
      "        hashValues.resize(primes);",
      "        powersOfBase.resize(primes);",
      "        inversePowersOfBase.resize(primes);",
      "        s = a;",
      "        n = s.length(); ",
      "        for(int i = 0; i < hashPrimes.size(); i++) {",
      "            powersOfBase[i].resize(n + 1);",
      "            inversePowersOfBase[i].resize(n + 1);",
      "            powersOfBase[i][0] = 1;",
      "            for(int j = 1; j <= n; j++){",
      "                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];",
      "            }",
      "            inversePowersOfBase[i][n] = mminvprime(powersOfBase[i][n], hashPrimes[i]);",
      "            for(int j = n - 1; j >= 0; j--){",
      "                inversePowersOfBase[i][j] = mod_mul(inversePowersOfBase[i][j + 1], base, hashPrimes[i]);",
      "            } ",
      "        }",
      "        for(int i = 0; i < hashPrimes.size(); i++) {",
      "            hashValues[i].resize(n);",
      "            for(int j = 0; j < n; j++){",
      "                hashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];",
      "                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];",
      "            }",
      "        }",
      "    }",
      "    vector<ll> substringHash(int l, int r){",
      "        vector<ll> hash(primes);",
      "        for(int i = 0; i < primes; i++){",
      "            ll val1 = hashValues[i][r];",
      "            ll val2 = l > 0 ? hashValues[i][l - 1] : 0LL;",
      "            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), inversePowersOfBase[i][l], hashPrimes[i]);",
      "        }",
      "        return hash;",
      "    }",
      "};"
    ],
    "description": "Priyansh's String Double Hashing template for CP"
  },
  /* ------------------------------------------------------ */
  "String Hashing": {
    "prefix": "string_hashing",
    "scope": "cpp",
    "body": [
      "struct Hashing {",
      "    string s;",
      "    ll base = 31;",
      "    ll prime = 1e9 + 9;",
      "    ll n;",
      "    vll base_pow;",
      "    vll prefix;",
      "",
      "    Hashing(string a) {",
      "        s = a;",
      "        n = s.size();",
      "        base_pow.resize(n);",
      "        prefix.resize(n);",
      "        base_pow[0] = 1;",
      "",
      "        for (ll i = 1; i < n; i++) {",
      "            base_pow[i] = (base_pow[i - 1] * base) % prime;",
      "        }",
      "        prefix[0] = s[0];",
      "        for (ll i = 1; i < n; i++) {",
      "            prefix[i] = ((prefix[i - 1] * base) % prime + s[i]) % prime;",
      "        }",
      "    }",
      "",
      "    ll substringHash(ll l, ll r) const {",
      "        ll val1 = prefix[r];",
      "        ll val2 = l > 0 ? prefix[l - 1] : 0LL;",
      "        ll h = ((val1 - ((val2 * base_pow[r - l + 1]) % prime) % prime) + prime)%prime;",
      "        return h;",
      "    }",
      "};"
    ],
    "description": "String Hashing (single hashing)"
  },
  /* ------------------------------------------------------ */
  "String Double Hashing (without MOD_FUN)": {
    "prefix": "string_double_hashing_no_mod",
    "scope": "cpp",
    "body": [
      "struct DoubleHashing {",
      "    string s;",
      "    ll base = 31;",
      "    vll primes = {1000000007};",
      "    ll n;",
      "    vector<vll> base_pow;",
      "    vector<vll> prefix;",
      "",
      "    DoubleHashing(string a) {",
      "        s = a;",
      "        n = s.size();",
      "        prefix.resize(primes.size());",
      "        base_pow.resize(primes.size());",
      "",
      "    for(ll i = 0; i<primes.size(); i++)",
      "    {",
      "        prefix[i].resize(n);",
      "        base_pow[i].resize(n);",
      "        base_pow[i][0] = 1;",
      "",
      "        for (ll j = 1; j < n; j++) {",
      "            base_pow[i][j] = (base_pow[i][j - 1] * base) % primes[i];",
      "        }",
      "        ",
      "        prefix[i][0] = s[0];",
      "        for (ll j = 1; j < n; j++) {",
      "            prefix[i][j] = ((prefix[i][j - 1] * base) % primes[i] + s[j]) % primes[i];",
      "        }",
      "",
      "    }",
      "        ",
      "    }",
      "",
      "    vll substringHash(ll l, ll r) const {",
      "        vll res;",
      "        for(int i = 0; i<primes.size(); i++)",
      "        {",
      "",
      "        ll val1 = prefix[i][r];",
      "        ll val2 = l > 0 ? prefix[i][l - 1] : 0LL;",
      "        ll h = ((val1 - ((val2 * base_pow[i][r - l + 1]) % primes[i]) % primes[i]) + primes[i])%primes[i];",
      "        res.push_back(h);",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "String Double Hashing (without MOD_FUN)"
  },
  /* ------------------------------------------------------ */
  "Rabin Karp": {
    "prefix": "rabin_karp",
    "scope": "cpp",
    "body": [
      "vll rabin_karp(string &s, string &t)",
      "{",
      "    Hashing hash_s(s);",
      "    Hashing hash_t(t);",
      "",
      "    ll window_size = t.size();",
      "",
      "    vll occs;",
      "",
      "    for(ll i = 0; i + window_size - 1<s.size(); i++)",
      "    {",
      "        vll cur_h = hash_s.substringHash(i, i+window_size-1);",
      "        if(cur_h[0] == hash_t.hashValues[0][t.size()-1] && cur_h[1] == hash_t.hashValues[1][t.size()-1])",
      "            occs.push_back(i);",
      "    }",
      "    return occs;",
      "}"
    ],
    "description": "Rabin Karp: Utilizes 'string_hashing' template"
  },
  /* ------------------------------------------------------ */
  "Apply Permutation k times": {
    "prefix": "apply_permutation",
    "scope": "cpp",
    "body": [
      "",
      "// apply a permutation to a sequence 'k' times",
      "vector<ll> applyPermutation(vector<ll> sequence, vector<ll> permutation) {",
      "    vector<ll> newSequence(sequence.size());",
      "    for(ll i = 0; i < sequence.size(); i++) {",
      "        newSequence[i] = sequence[permutation[i]];",
      "    }",
      "    return newSequence;",
      "}",
      "",
      "vector<ll> permute(vector<ll> sequence, vector<ll> permutation, long long k) {",
      "    while (k > 0) {",
      "        if (k & 1) {",
      "            sequence = applyPermutation(sequence, permutation);",
      "        }",
      "        permutation = applyPermutation(permutation, permutation);",
      "        k >>= 1;",
      "    }",
      "    return sequence;",
      "}"
    ],
    "description": "Applying a permutation k times to an array"
  },
  /* ------------------------------------------------------ */
  "KMP String Searching": {
    "prefix": "kmp",
    "scope": "cpp",
    "body": [
      "/* ------------------------- KMP ------------------------ */",
      "vector<ll> kmp_prefix_function(string s) {",
      "    ll n = (ll)s.length();",
      "    vector<ll> pi(n);",
      "    for (ll i = 1; i < n; i++) {",
      "        ll j = pi[i-1];",
      "        while (j > 0 && s[i] != s[j])",
      "            j = pi[j-1];",
      "        if (s[i] == s[j])",
      "            j++;",
      "        pi[i] = j;",
      "    }",
      "    return pi;",
      "}",
      "",
      "vector<ll> kmp_search(string &s, string &t)",
      "{",
      "    ll j = 0;",
      "    vector<ll> p = kmp_prefix_function(t);",
      "    vector<ll> ans;",
      "",
      "    for(ll i = 0; i<s.size(); i++)",
      "    {",
      "        while(j>0 && s[i] != t[j])",
      "            j=p[j-1];",
      "",
      "        if(s[i] == t[j])",
      "            j++;",
      "            ",
      "        if(j==t.size()){",
      "            ans.push_back(i-t.size() + 1);",
      "            j=p[j-1];",
      "        }",
      "    }",
      "    return ans;",
      "}",
      "/* ---------------------- KMP ends ---------------------- */"
    ],
    "description": "KMP String Searching Algorithm"
  },
  /* ------------------------------------------------------ */
  "Z Function": {
    "prefix": "z_function",
    "scope": "cpp",
    "body": [
      "vector<ll> z_function(string &s) {",
      "    ll n = (ll) s.length();",
      "    vector<ll> z(n);",
      "    for (ll i = 1, l = 0, r = 0; i < n; ++i) {",
      "        if (i <= r)",
      "            z[i] = min (r - i + 1, z[i - l]);",
      "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
      "            ++z[i];",
      "        if (i + z[i] - 1 > r)",
      "            l = i, r = i + z[i] - 1;",
      "    }",
      "    return z;",
      "}"
    ],
    "description": "Z Function"
  },
  /* ------------------------------------------------------ */
  "Custom Hash - neal/codeforces": {
    "prefix": "custom_hash",
    "scope": "cpp",
    "body": [
      "struct custom_hash {",
      "    static uint64_t splitmix64(uint64_t x) {",
      "        // http://xorshift.di.unimi.it/splitmix64.c",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "    size_t operator()(uint64_t x) const {",
      "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return splitmix64(x + FIXED_RANDOM);",
      "    }",
      "    // custom string hash, not sure how efficient it is :",
      "    size_t operator()(const string& s) const {",
      "            static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "            size_t hash = 0;",
      "            for (char c : s) {",
      "                hash = hash * 31 + c;",
      "            }",
      "            return splitmix64(hash + FIXED_RANDOM);",
      "    }",
      "};",
      ""
    ],
    "description": ""
  },
  /* ------------------------------------------------------ */
  }
  